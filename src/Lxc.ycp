/* ------------------------------------------------------------------------------
 * Copyright (c) 2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Lxc.ycp
 * Package:	Configuration of lxc
 * Summary:	Lxc settings, input and output functions
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of lxc.
 * Input and output routines.
 */

{

module "Lxc";
textdomain "lxc";

import "Progress";
import "Security";


// text or graphic mode?
global boolean textmode        = false;

// current password encryption method
string method           = "des";

// read list of available templates
global list<term> ReadTemplates () {

  list<term> ret      = [];
  map out = (map) SCR::Execute (.target.bash_output, "rpm -ql lxc | grep 'templates/' | cut -f 2 -d -");
  if (out["stdout"]:"" != "")
  {
    foreach (string line, sort (splitstring (out["stdout"]:"", "\n")), {
      if (line != "")
      {
        ret     = add (ret,
          // sles goes later = selected if present
          `item (line, line == "sles" || line == "opensuse"));
      }
    });
  }
  return ret;
}

// encrypt given password using current method
global string CryptPassword (string pw) {

    if (method == "md5")
	return cryptmd5 (pw);
    if (method == "blowfish")
	return cryptblowfish (pw);
    if (method == "sha256")
	return cryptsha256 (pw);
    if (method == "sha512")
	return cryptsha512 (pw);
    return crypt (pw);
}

global list<string> ReadBridgesIds () {

    map out     = (map) SCR::Execute (.target.bash_output, "brctl show | tail -n +2 | cut -f 1");
    list<string> ret    = [];

    if (out["stdout"]:"" != "")
    {
      ret       = maplist (string line, splitstring (out["stdout"]:"", "\n"), ``(line));
    }
    return ret;
}

global list<term> GetContainers () {

  list<term> ret      = [];
  map out = (map) SCR::Execute (.target.bash_output, "lxc-ls -1");

  foreach (string line, sort (splitstring (out["stdout"]:"", "\n")), {
    if (line != "")
    {
      string cmd= sformat ("lxc-info -n %1 | grep state", line);
      out       = (map) SCR::Execute (.target.bash_output, cmd, $[ "LANG" : "C" ]);
      list<string> state        = splitstring (deletechars (out["stdout"]:"", " \t\n"), ":");
      ret     = add (ret, `item (line, state[1]:""));
      // FIXME translate
    }
  });
  return ret;
}

/**
 * Read all lxc settings
 * @return true on success
 */
global boolean Read() {

    /* Lxc read dialog caption */
    string caption = _("Initializing LXC Configuration");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    // Progress stage
	    _("Check LXC availability"),
	    // Progress stage
	    _("Read system settings"),
	], [
	    // Progress step
	    _("Check LXC availability..."),
	    // Progress step
	    _("Reading system settings..."),
	    // Progress finished
	    _("Finished")
	],
	""
    );


    Progress::NextStage();

    // FIXME run lxc-checkconfig at start

    Progress::NextStage();

    boolean orig        = Progress::set (false);

    Security::Read ();

    Progress::set (orig);

    map security        = Security::Export ();
    method              = tolower (security["PASSWD_ENCRYPTION"]:"des");

    textmode            = UI::GetDisplayInfo()["TextMode"]:false;

    Progress::NextStage();

    return true;
}

/* EOF */
}
